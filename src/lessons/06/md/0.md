## Functions

Functions are like recipes. They are just a set of steps that we are grouping together and can call at any time by actually 'running' or 'invoking' said function.

The problem is that with the rise of ES6 and its fancy arrow syntax, it has completely replaced the keyword `function` itself, really forcing your brain to always stop for a second and figure out what this strange hierogliphics(sp?) are before you understand what is happening.

This has been one place where Javascript has gone one step forward, but two steps back when it comes to adoption by others. So while you still have your training wheels on, we'll focus on writing out functions the ol' fashioned way.

This is what a function looks like:

~~~js
function sayHello(){
  // inside this safe space we'll write out our instructions to the browser to open a modal  
}

sayHello(); // and this how we'll call our function when we are ready, but more on that later.
~~~

As you can see, we use the keyword `function` followed by the name we want to use for our new function. This is followed by an opening `()` and then an opening `{` where all the steps in our function will reside before closing everything up with a `}`.

While you can name your function whatever you like, it's good practice and a courtesy to your fellow developers to name the function as a *verb* that describes exactly what your function does. And just like variables, we use [camelcase formatting](http://www.google.com) for our function names. [**SHOULD BE MENTIONED IN VAR CHAPTER**]

That's all great and all, but your function's contents will never see the light of the day unless the function is actually triggered. In Javascript land, this is referred to as calling, running -- or when you are feeling super nerdy -- invoking a function.

Calling a function is simply done by using the name of the function immediately followed by an opening and closing `()`.

A function can also work like a pipeline that can take one or more values, and return one at the end. How exactly does that work? Let's look at this example:

~~~js
function sayHello(yourName){
  return 'Hi, my name is ' + yourName;
}

sayHello('John');
~~~

In our modified `sayHello` function, we now take a value *input* that we'll call `yourName` on one end of the pipeline. This input is called a `parameter` in Javascript. At the other end of the pipeline, this function will do its thing and then return that value as part of the sentence "Hi, ny name is ..." and add the name value at the end.

And *how* do we exactly shove a value down the input side of the function pipeline? You probably guessed it by now, but when you run your function and pass it a value insde the opening and closing `()`, *this* is the exact same value that will be passed down to our specialized pipeline for processing and becomes the `yourName` parameter value.

## Anonymous functions
One last thing before we move on: While we stated above that functions use the keyword `function` followed by a name you make up, there's also another type of function. A shy type that doesn't have a name, and these go by the name of 'anonymous' functions in Javascript.

Anonymous functions are just functions with no specific name given. The most common way an anonymous function is used in Javascript is by first storing itself in a variable. At that point the variable and the function are basically one and the same, and you can execute/run/call/invoke your function by calling your variable name followed by the `()` just like you would on a regular function.

Here's a quick example to show this:

~~~~js
var sayMyNameSayMyName = function (yourName){
  return 'Hi, my name is ' + yourName;
}

sayMyNameSayMyName('John');
~~~~

We'll see an example of this later on but just keep this in the back of your mind for now.

## Callbacks
Ok, I lied. One more thing that's pretty important in Javascript-land when it comes to functions. And that's the tricky callback function. 

These can be tough to wrap your mind around in the beginning, but just think of it as this: A callback function is just a regular ol' function that triggers ONLY after another function is called.

Let's go back to our button example that triggers a modal. What's the next step to make this happen? The next step is to set a 'callback' function to be run ONLY AFTER the user triggers the button with a click event:

~~~html
<button class="btn">learn more</button>
~~~

~~~~js
var buttonNode = $('.btn');

buttonNode.on('click', function(){
  // we are now inside our callback function, the steps we put here will run AFTER the user clicks on the button
});
~~~~

If you are a sharp observer, you'll realized that we have TWO functions here:
  - One is the `on()` function (technically a `method` as it's a function inside an object).
  - The other is our shy anonymous function that's passed as a *second parameter* inside the `on()` function.

Does that make sense? If it doesn't, let's write it another way: Let's first assign our shy anonymous function a name an then pass that as our callback function to our on click event.

~~~js
var buttonNode = $('.btn');

function triggerModalPopup(){
  // instructions here to open our super secret modal popup
}

buttonNode.on('click', triggerModalPopup);
~~~

Make more sense now? Either way is a valid way to write it. As long as it makes sense to you  -- and doesn't make your fellow developers think too much -- they are both perfectly acceptable ways of using callback functions.

Just remember that at then of the day, a callback function is a function that gets triggered inside another function.




